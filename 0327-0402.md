# March, 2023
|Mon|Tue|Wed|Thu|Fri|Sat|Sun|
|-|-|-|-|-|-|-|
|27|28|29|30|31|1|2|

## **Problem List**
|problemID|name|difficulty|lastChange|status|time complexity|beat|comment|recorded|
|-|-|-|-|-|-|-|-|-|
|64|Minimum Path Sum|Medium|03/27/2023|AC|O(m*n)|99%|DP|Y|
|310|Minimum Height Trees|Medium|03/27/2023|AC|O(n)|96%|Graph|Y|

## 64. Minimum Path Sum
> DP AC 03/27/2023   

![](./pics/64.png)

### **Solution**

* Typical dynamic programming problem, time complexity O(m * n), space complexity O(n).

### **Java**
```java {.line-numbers}
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int[] cur = grid[0];
        int n = cur.length;
        int[] pre = new int[n];
        for(int i = 1; i < n; ++i) {
            cur[i] += cur[i - 1];
            // System.out.println(cur[i]);
        }
        System.arraycopy(cur, 0, pre, 0, n);
        for(int i = 1; i < m; ++i) {
            cur[0] = pre[0] + grid[i][0]; 
            for(int j = 1; j < n; ++j) {
                cur[j] = pre[j] < cur[j - 1] ? pre[j] + grid[i][j] : cur[j - 1] + grid[i][j];
                // System.out.println(cur[j]);
            }
            System.arraycopy(cur, 0, pre, 0, n);
        }
        return cur[n - 1];
    }
}
```

## 310. Minimum Height Trees
> AC 03/27

![](./pics/310-1.png)
![](./pics/310-2.png)

### **Solution**
* The main thought is to trim leave nodes. After trimming most leaves, the 'core' remaining inside (1 or 2 points) is what we want. 
* The python version 1 has time complexity of O(n^2), nearly passes all testcases(70/71). Maybe quicker if optimized.
* The time complexity can be optimized using set() to replace list when recording the graph with adjacent list, like python version 2.
only O(n) now.

### Python Version 1
```python {.line-numbers}
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if(n == 1): return [0]
        G = [[] for _ in range(n)]
        d = [0] * n
        for i in range(n - 1):
            a = edges[i][0]
            b = edges[i][1]
            d[a] += 1
            d[b] += 1
            G[a].append(b)
            G[b].append(a)

        rm = []
        remain = [True] * n
        while(True):
            for i in range(n):
                if(d[i] == 1):
                    rm.append(i)
                elif(d[i] == 0 and remain[i]):
                    rm.append(i)

            if(self.countRemain(remain) <= 2):
                return rm
            else:
                for node in rm:
                    d[node] -= 1
                    remain[node] = False
                    for x in G[node]:
                        d[x] -= 1
                rm = []
                
    def countRemain(self, remain) :
        sum = 0
        for x in remain:
            if(x): sum += 1
        return sum

```

### Python Version 2 [reference](https://leetcode.com/problems/minimum-height-trees/solutions/76055/share-some-thoughts/)
```python {.line-numbers}
class Solution:
    def findMinHeightTrees(self, n, edges):
        if n == 1: return [0] 
        adj = [set() for _ in range(n)]
        for i, j in edges:
            adj[i].add(j)
            adj[j].add(i)

        leaves = [i for i in range(n) if len(adj[i]) == 1]

        while n > 2:
            n -= len(leaves)
            newLeaves = []
            for i in leaves:
                j = adj[i].pop()
                adj[j].remove(i)
                if len(adj[j]) == 1: newLeaves.append(j)
            leaves = newLeaves
        return leaves
```